/* DO NOT EDIT THIS FILE - it is machine generated */
/* 头文件begin */
#include "iyouxun.h"

#ifdef __cplusplus
extern "C" {

#endif

/* 内全局变量begin */
static char TAG[] = "UninstalledObserverActivity.init";
static jboolean isCopy = JNI_TRUE;
static const char APP_DIR[] = "/data/data/com.iyouxun";
static const char APP_FILES_DIR[] = "/data/data/com.iyouxun/lib/libiyouxun.so";
char Req[400];

/* 内全局变量 */
/*
 * Class:     com_iyouxun_activity_UninstallReceiverService
 * Method:    uninstalledMoniter
 * Signature: ()V
 */
JNIEXPORT int JNICALL Java_com_iyouxun_service_uninstall_UninstallReceiverService_init
(JNIEnv *env, jobject obj,jstring userSerial,jstring destIp,jstring url)
{

	jstring tag = (*env)->NewStringUTF(env, TAG);

	LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy)
			, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "init observer"), &isCopy));

	//LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy),(*env)->GetStringUTFChars(env, url, &isCopy));

	// fork子进程，以执行轮询任务
	pid_t pid = fork();
	if (pid < 0)
	{
		LOG_ERROR((*env)->GetStringUTFChars(env, tag, &isCopy)
				, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "fork failed !!!"), &isCopy));

		exit(1);
	}
	else if (pid == 0)
	{
		// 分配空间，以便读取event
		void *p_buf = malloc(sizeof(struct inotify_event));
		if (p_buf == NULL)
		{
			LOG_ERROR((*env)->GetStringUTFChars(env, tag, &isCopy)
					, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "malloc failed !!!"), &isCopy));

			exit(1);
		}
		// 分配空间，以便打印mask
		int maskStrLength = 7 + 10 + 1;// mask=0x占7字节，32位整形数最大为10位，转换为字符串占10字节，'\0'占1字节
		char *p_maskStr = malloc(maskStrLength);
		if (p_maskStr == NULL)
		{
			free(p_buf);

			LOG_ERROR((*env)->GetStringUTFChars(env, tag, &isCopy)
					, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "malloc failed !!!"), &isCopy));

			exit(1);
		}

		// 开始监听
		LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy)
				, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "start observe"), &isCopy));

		// 初始化
		int fileDescriptor = inotify_init();
		if (fileDescriptor < 0)
		{
			free(p_buf);
			free(p_maskStr);

			LOG_ERROR((*env)->GetStringUTFChars(env, tag, &isCopy)
					, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "inotify_init failed !!!"), &isCopy));

			exit(1);
		}

		// 添加被监听文件到监听列表
		int watchDescriptor = inotify_add_watch(fileDescriptor, APP_FILES_DIR, IN_ALL_EVENTS);
		if (watchDescriptor < 0)
		{
			free(p_buf);
			free(p_maskStr);

			LOG_ERROR((*env)->GetStringUTFChars(env, tag, &isCopy)
					, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "inotify_add_watch failed !!!"), &isCopy));

			exit(1);
		}

		while(1)
		{
			// read会阻塞进程
			size_t readBytes = read(fileDescriptor, p_buf, sizeof(struct inotify_event));

			// 打印mask
			snprintf(p_maskStr, maskStrLength, "mask=0x%x\0", ((struct inotify_event *) p_buf)->mask);

			LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy)
					, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, p_maskStr), &isCopy));

			// 若文件被删除，可能是已卸载，还需进一步判断app文件夹是否存在
			if (4 == ((struct inotify_event *) p_buf)->mask)
			{
				sleep(1);
				 FILE *p_appDir = fopen(APP_DIR, "r");
				// 确认已卸载
				if (p_appDir == NULL)
				{
					LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy)
											, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "uninstall"), &isCopy));
					break;
				}else{
					//执行了更新操作，直接退出进程
					LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy)
																, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "update"), &isCopy));
					exit(1);
				}
			}
		}

		// 释放资源
		free(p_buf);
		free(p_maskStr);

		// 停止监听
		LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy)
				, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "stop observe"), &isCopy));

		//发送卸载联网请求
		netConn(tag,env,destIp,url);

		//添加渠道id
		//const char *channelID = (*env)->GetStringUTFChars(env, channel, &isCopy);
		//const char *meiID = (*env)->GetStringUTFChars(env, mei, &isCopy);
		//char url[200];
		//sprintf(url,"http://www.iyouxun.com/apps/feedback?mei=%s&channelID=%s",meiID,channelID);
		if (userSerial == NULL)
		{
			//执行命令am start -a android.intent.action.VIEW -d http://iyouxun.com/apps/feedback
			execlp("am", "am", "start", "-a", "android.intent.action.VIEW", "-d", "http://www.iyouxun.com/apps/feedback", (char *)NULL);
		}
		else
		{
			// 执行命令am start --user userSerial -a android.intent.action.VIEW -d http://iyouxun.com/apps/feedback
			execlp("am", "am", "start", "--user", (*env)->GetStringUTFChars(env, userSerial, &isCopy), "-a", "android.intent.action.VIEW", "-d",
					"http://www.iyouxun.com/apps/feedback", (char *)NULL);
		}

		// 执行命令失败log
		LOG_ERROR((*env)->GetStringUTFChars(env, tag, &isCopy)
				, (*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env, "exec AM command failed !!!"), &isCopy));

		exit(1);
	}
	else
	{
		// 父进程直接退出，使子进程被init进程领养，以避免子进程僵死，同时返回子进程pid
		return pid;
	}
}

/*JNIEXPORT int JNICALL Java_com_iyouxun_service_uninstall_UninstallReceiverService_sendMessage
 (JNIEnv *env, jobject obj,jint uid){


 jstring tag = (*env)->NewStringUTF(env, TAG);

 char *uidtemp ;// = (*env)->GetStringUTFChars(env, uidStr, &isCopy);

 sprintf(uidtemp,"%d",uid);

 LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy),(*env)->GetStringUTFChars(env, uidtemp, &isCopy));

 }*/

void netConn(jstring tag, JNIEnv *env,jstring destIp, jstring url) {

	//char *uidtemp ;// = (*env)->GetStringUTFChars(env, uidStr, &isCopy);

	//sprintf(uidtemp,"%d",uid);

	//LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy),(*env)->GetStringUTFChars(env, uidtemp, &isCopy));

//	const char *macString = (*env)->GetStringUTFChars(env, mac, &isCopy);
	const char *DestIp = (*env)->GetStringUTFChars(env, destIp, &isCopy);
//	const char *channelID = (*env)->GetStringUTFChars(env, channel, &isCopy);
//	const char *meiID = (*env)->GetStringUTFChars(env, mei, &isCopy);
//	const char *mobileID = (*env)->GetStringUTFChars(env, mobile, &isCopy);
//	const char *reqID = (*env)->GetStringUTFChars(env, req, &isCopy);
//
//	// const char *uidStr = (*env)->GetStringUTFChars(env, uidtemp, &isCopy);
//
//	//LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy)
//	//         ,uidStr);
//
//	sprintf(Req, "%s&mobile=%s&mac=%s&channelID=%s&meiID=%s %s", reqID, mobileID,macString, channelID,meiID,
//			ReqHost);

	const char *ReqID = (*env)->GetStringUTFChars(env, url, &isCopy);
	sprintf(Req, "%s",ReqID);
	int nRequestLen = sizeof(Req);
	LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy),Req);
	ssize_t i;
	char strResponse[BUFSIZE] = { 0 };
	char strRequest[BUFSIZE] = { 0 };

	int sockfd, numbytes;
	struct sockaddr_in dest_addr; /* connector's address information */

	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy),
				(*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env,
						"scoket"), &isCopy));
		return;
	}

	dest_addr.sin_family = AF_INET; /* host byte order */
	dest_addr.sin_port = htons(DestPort); /* short, network byte order */
	dest_addr.sin_addr.s_addr = inet_addr(DestIp);

	/* Create and setup the connection */
	if (connect(sockfd, (struct sockaddr *) &dest_addr, sizeof(struct sockaddr))
			== -1) {
		LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy),
				(*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env,
						"connect fail"), &isCopy));
		return;
	}

	/* Send the request */
	strncpy(strRequest, Req, nRequestLen);
	if (write(sockfd, strRequest, nRequestLen) == -1) {
		LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy),
				(*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env,
						"write"), &isCopy));
		return;
	}

	/* Read in the response */
	while (1) {
		i = read(sockfd, strResponse, BUFSIZE - 1);
		if (0 >= i) {
			break;
		}
		strResponse[i] = '\0';
		//printf(strResponse);
		LOG_DEBUG((*env)->GetStringUTFChars(env, tag, &isCopy),
				(*env)->GetStringUTFChars(env, (*env)->NewStringUTF(env,
						strResponse), &isCopy));

	}

	/* Close the connection */
	close(sockfd);
}

#ifdef __cplusplus
}
#endif
